import fs from 'fs';
import { promises as fsPromises } from 'fs';
import path from 'path';
import isBinaryPath from 'is-binary-path';

export class SnapshotFormatter {
  static estimateTokens(content: string): number {
    return Math.ceil(content.length / 4);
  }

  static async generateSnapshot(
    rootDir: string,
    files: string[],
    outputPath: string = 'd2f_dump.txt'
  ): Promise<void> {
    const tempPath = '.d2f_tmp';
    const stream = fs.createWriteStream(tempPath, { encoding: 'utf-8' });

    // Header
    const date = new Date().toISOString().split('T')[0];
    stream.write(`# D2F_SNAPSHOT_START | Date: ${date} | Root: ${rootDir}\n`);
    stream.write(`# Context: Development State Snapshot\n`);
    stream.write(`# Generated by: D2F CLI (v1.0.0)\n`);
    stream.write(`# ----------------------------------------------------------------\n`);
    stream.write(`# üèóÔ∏è PROJECT ARCHITECTURE\n`);
    stream.write(`# ----------------------------------------------------------------\n`);
    stream.write(`.\n`); // Root dot

    // Architecture Tree
    const tree = this.buildTree(files);
    stream.write(tree + '\n');

    stream.write(`# ----------------------------------------------------------------\n`);
    stream.write(`# üìÑ FILE CONTENT START\n`);
    stream.write(`# ----------------------------------------------------------------\n\n`);

    // Content Blocks
    for (const file of files) {
      // Normalize path to forward slashes
      const normalizedPath = file.split(path.sep).join('/');
      stream.write(`--- PATH: ${normalizedPath} ---\n`);

      const fullPath = path.join(rootDir, file);

      try {
        if (isBinaryPath(file)) {
          stream.write(`[SKIPPED: BINARY DATA]\n\n`);
        } else {
            const content = await fsPromises.readFile(fullPath, 'utf-8');
            stream.write(content + '\n\n');
        }
      } catch (err) {
        stream.write(`[ERROR READING FILE: ${err}]\n\n`);
      }
    }

    stream.write(`# ----------------------------------------------------------------\n`);
    stream.write(`# üìÑ FILE CONTENT END\n`);
    stream.write(`# [EOF: D2F_SNAPSHOT_END]\n`);

    stream.end();

    await new Promise<void>((resolve, reject) => {
      stream.on('finish', resolve);
      stream.on('error', reject);
    });

    await fsPromises.rename(tempPath, outputPath);
  }

  private static buildTree(files: string[]): string {
    const root: any = {};

    for (const file of files) {
      // Normalize path separators to forward slashes for consistency
      const normalized = file.split(path.sep).join('/');
      const parts = normalized.split('/');
      let current = root;
      for (const part of parts) {
        if (!current[part]) {
          current[part] = {};
        }
        current = current[part];
      }
    }

    return this.renderTree(root, '');
  }

  private static renderTree(node: any, prefix: string): string {
    let output = '';
    const keys = Object.keys(node).sort((a, b) => {
        // Directories first (heuristic: nodes with children are dirs)
        const aHasChildren = Object.keys(node[a]).length > 0;
        const bHasChildren = Object.keys(node[b]).length > 0;

        if (aHasChildren && !bHasChildren) return -1;
        if (!aHasChildren && bHasChildren) return 1;
        return a.localeCompare(b);
    });

    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      const isLast = i === keys.length - 1;
      const connector = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';

      output += `${prefix}${connector}${key}\n`;

      const children = node[key];
      if (Object.keys(children).length > 0) {
        const childPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
        output += this.renderTree(children, childPrefix);
      }
    }
    return output;
  }
}
